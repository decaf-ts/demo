import { apply, metadata } from '@decaf-ts/reflection';
import { NgxRenderingEngine } from './NgxRenderingEngine';
import { AngularEngineKeys } from './constants';
import { InternalError } from '@decaf-ts/db-decorators';
import { reflectComponentType } from '@angular/core';
/**
 * @description Marks an Angular component as dynamically loadable
 * @summary Decorator that registers an Angular component with the NgxRenderingEngine for dynamic loading.
 * This decorator must be applied before the @Component decorator to properly extract component metadata.
 * It adds metadata to the component class and registers it with the rendering engine using its selector.
 * @function Dynamic
 * @return {Function} A decorator function that can be applied to Angular component classes
 * @mermaid
 * sequenceDiagram
 *   participant C as Component Class
 *   participant D as Dynamic Decorator
 *   participant R as NgxRenderingEngine
 *   participant M as Angular Metadata
 *   C->>D: Apply decorator
 *   D->>M: reflectComponentType()
 *   M-->>D: Return component metadata
 *   alt No metadata found
 *     D->>D: Throw InternalError
 *   else Metadata found
 *     D->>R: registerComponent(selector, constructor)
 *     D->>C: Apply metadata
 *   end
 * @category Decorators
 */
export function Dynamic() {
    return apply((original) => {
        const metadata = reflectComponentType(original);
        if (!metadata)
            throw new InternalError(`Could not find Component metadata. @Dynamic decorator must come above @Component`);
        NgxRenderingEngine.registerComponent(metadata.selector, original);
    }, metadata(NgxRenderingEngine.key(AngularEngineKeys.DYNAMIC), true));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb3JhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvZW5naW5lL2RlY29yYXRvcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUN2RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMxRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFaEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3hELE9BQU8sRUFBRSxvQkFBb0IsRUFBUSxNQUFNLGVBQWUsQ0FBQztBQUUzRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1Qkc7QUFDSCxNQUFNLFVBQVUsT0FBTztJQUNyQixPQUFPLEtBQUssQ0FDVixDQUFDLFFBQWdCLEVBQUUsRUFBRTtRQUNuQixNQUFNLFFBQVEsR0FBRyxvQkFBb0IsQ0FBQyxRQUF5QixDQUFDLENBQUM7UUFFakUsSUFBSSxDQUFDLFFBQVE7WUFDWCxNQUFNLElBQUksYUFBYSxDQUNyQixrRkFBa0YsQ0FDbkYsQ0FBQztRQUVKLGtCQUFrQixDQUFDLGlCQUFpQixDQUNsQyxRQUFRLENBQUMsUUFBUSxFQUNqQixRQUEyQyxDQUM1QyxDQUFDO0lBQ0osQ0FBQyxFQUNELFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQ2xFLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwbHksIG1ldGFkYXRhIH0gZnJvbSAnQGRlY2FmLXRzL3JlZmxlY3Rpb24nO1xuaW1wb3J0IHsgTmd4UmVuZGVyaW5nRW5naW5lIH0gZnJvbSAnLi9OZ3hSZW5kZXJpbmdFbmdpbmUnO1xuaW1wb3J0IHsgQW5ndWxhckVuZ2luZUtleXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb25zdHJ1Y3RvciB9IGZyb20gJ0BkZWNhZi10cy9kZWNvcmF0b3ItdmFsaWRhdGlvbic7XG5pbXBvcnQgeyBJbnRlcm5hbEVycm9yIH0gZnJvbSAnQGRlY2FmLXRzL2RiLWRlY29yYXRvcnMnO1xuaW1wb3J0IHsgcmVmbGVjdENvbXBvbmVudFR5cGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gTWFya3MgYW4gQW5ndWxhciBjb21wb25lbnQgYXMgZHluYW1pY2FsbHkgbG9hZGFibGVcbiAqIEBzdW1tYXJ5IERlY29yYXRvciB0aGF0IHJlZ2lzdGVycyBhbiBBbmd1bGFyIGNvbXBvbmVudCB3aXRoIHRoZSBOZ3hSZW5kZXJpbmdFbmdpbmUgZm9yIGR5bmFtaWMgbG9hZGluZy5cbiAqIFRoaXMgZGVjb3JhdG9yIG11c3QgYmUgYXBwbGllZCBiZWZvcmUgdGhlIEBDb21wb25lbnQgZGVjb3JhdG9yIHRvIHByb3Blcmx5IGV4dHJhY3QgY29tcG9uZW50IG1ldGFkYXRhLlxuICogSXQgYWRkcyBtZXRhZGF0YSB0byB0aGUgY29tcG9uZW50IGNsYXNzIGFuZCByZWdpc3RlcnMgaXQgd2l0aCB0aGUgcmVuZGVyaW5nIGVuZ2luZSB1c2luZyBpdHMgc2VsZWN0b3IuXG4gKiBAZnVuY3Rpb24gRHluYW1pY1xuICogQHJldHVybiB7RnVuY3Rpb259IEEgZGVjb3JhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gQW5ndWxhciBjb21wb25lbnQgY2xhc3Nlc1xuICogQG1lcm1haWRcbiAqIHNlcXVlbmNlRGlhZ3JhbVxuICogICBwYXJ0aWNpcGFudCBDIGFzIENvbXBvbmVudCBDbGFzc1xuICogICBwYXJ0aWNpcGFudCBEIGFzIER5bmFtaWMgRGVjb3JhdG9yXG4gKiAgIHBhcnRpY2lwYW50IFIgYXMgTmd4UmVuZGVyaW5nRW5naW5lXG4gKiAgIHBhcnRpY2lwYW50IE0gYXMgQW5ndWxhciBNZXRhZGF0YVxuICogICBDLT4+RDogQXBwbHkgZGVjb3JhdG9yXG4gKiAgIEQtPj5NOiByZWZsZWN0Q29tcG9uZW50VHlwZSgpXG4gKiAgIE0tLT4+RDogUmV0dXJuIGNvbXBvbmVudCBtZXRhZGF0YVxuICogICBhbHQgTm8gbWV0YWRhdGEgZm91bmRcbiAqICAgICBELT4+RDogVGhyb3cgSW50ZXJuYWxFcnJvclxuICogICBlbHNlIE1ldGFkYXRhIGZvdW5kXG4gKiAgICAgRC0+PlI6IHJlZ2lzdGVyQ29tcG9uZW50KHNlbGVjdG9yLCBjb25zdHJ1Y3RvcilcbiAqICAgICBELT4+QzogQXBwbHkgbWV0YWRhdGFcbiAqICAgZW5kXG4gKiBAY2F0ZWdvcnkgRGVjb3JhdG9yc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRHluYW1pYygpIHtcbiAgcmV0dXJuIGFwcGx5KFxuICAgIChvcmlnaW5hbDogb2JqZWN0KSA9PiB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHJlZmxlY3RDb21wb25lbnRUeXBlKG9yaWdpbmFsIGFzIFR5cGU8dW5rbm93bj4pO1xuXG4gICAgICBpZiAoIW1ldGFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgQ29tcG9uZW50IG1ldGFkYXRhLiBARHluYW1pYyBkZWNvcmF0b3IgbXVzdCBjb21lIGFib3ZlIEBDb21wb25lbnRgXG4gICAgICAgICk7XG5cbiAgICAgIE5neFJlbmRlcmluZ0VuZ2luZS5yZWdpc3RlckNvbXBvbmVudChcbiAgICAgICAgbWV0YWRhdGEuc2VsZWN0b3IsXG4gICAgICAgIG9yaWdpbmFsIGFzIHVua25vd24gYXMgQ29uc3RydWN0b3I8dW5rbm93bj5cbiAgICAgICk7XG4gICAgfSxcbiAgICBtZXRhZGF0YShOZ3hSZW5kZXJpbmdFbmdpbmUua2V5KEFuZ3VsYXJFbmdpbmVLZXlzLkRZTkFNSUMpLCB0cnVlKVxuICApO1xufVxuIl19